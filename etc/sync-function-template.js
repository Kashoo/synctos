// This sync function for Couchbase Sync Gateway was generated by synctos: https://github.com/Kashoo/synctos
// More info on sync functions: http://developer.couchbase.com/mobile/develop/guides/sync-gateway/sync-function-api-guide/index.html
function synctos(doc, oldDoc) {
  // Determine if a given value is an integer. Exists as a failsafe because Number.isInteger is not guaranteed to exist in all environments.
  var isInteger = Number.isInteger || function(value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };

  // Check that a given value is a valid ISO 8601 format date string with optional time and time zone components
  function isIso8601DateTimeString(value) {
    var regex = new RegExp('^(([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01]))([T ]([01][0-9]|2[0-4])(:[0-5][0-9])?(:[0-5][0-9])?([\\.,][0-9]{1,3})?)?([zZ]|([\\+-])([01][0-9]|2[0-3]):?([0-5][0-9])?)?$');

    return regex.test(value);
  }

  // Check that a given value is a valid ISO 8601 date string without time and time zone components
  function isIso8601DateString(value) {
    var regex = new RegExp('^(([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01]))$');

    return regex.test(value);
  }

  // Whether the given value is either null or undefined
  function isValueNullOrUndefined(value) {
    return typeof(value) === 'undefined' || value === null;
  }

  // Whether the given document is missing/nonexistant (i.e. null or undefined) or deleted (its "_deleted" property is true)
  function isDocumentMissingOrDeleted(candidate) {
    return isValueNullOrUndefined(candidate) || candidate._deleted;
  }

  // A property validator that is suitable for use on type identifier properties. Ensures the value is a string, is neither null nor
  // undefined, is not an empty string and cannot be modified.
  var typeIdValidator = {
    type: 'string',
    required: true,
    mustNotBeEmpty: true,
    immutable: true
  };

  // A type filter that matches on the document's type property
  function simpleTypeFilter(doc, oldDoc, candidateDocType) {
    if (oldDoc) {
      if (doc._deleted) {
        return oldDoc.type === candidateDocType;
      } else {
        return doc.type === oldDoc.type && oldDoc.type === candidateDocType;
      }
    } else {
      return doc.type === candidateDocType;
    }
  }

  // Retrieves the old doc's effective value. If it is null, undefined or its "_deleted" property is true, returns null. Otherwise, returns
  // the value of the "oldDoc" parameter.
  function getEffectiveOldDoc(oldDoc) {
    return !isDocumentMissingOrDeleted(oldDoc) ? oldDoc : null;
  }

  // A document definition may define its authorizations (channels, roles or users) for each operation type (view, add, replace, delete or
  // write) as either a string or an array of strings. In either case, add them to the list if they are not already present.
  function appendToAuthorizationList(allAuthorizations, authorizationsToAdd) {
    if (!isValueNullOrUndefined(authorizationsToAdd)) {
      if (authorizationsToAdd instanceof Array) {
        for (var i = 0; i < authorizationsToAdd.length; i++) {
          var authorization = authorizationsToAdd[i];
          if (allAuthorizations.indexOf(authorization) < 0) {
            allAuthorizations.push(authorization);
          }
        }
      } else if (allAuthorizations.indexOf(authorizationsToAdd) < 0) {
        allAuthorizations.push(authorizationsToAdd);
      }
    }
  }

  // A document definition may define its authorized channels, roles or users as either a function or an object/hashtable
  function getAuthorizationMap(doc, oldDoc, authorizationDefinition) {
    if (typeof(authorizationDefinition) === 'function') {
      return authorizationDefinition(doc, getEffectiveOldDoc(oldDoc));
    } else {
      return authorizationDefinition;
    }
  }

  // Retrieves a list of channels the document belongs to based on its specified type
  function getAllDocChannels(doc, oldDoc, docDefinition) {
    var docChannelMap = getAuthorizationMap(doc, oldDoc, docDefinition.channels);

    var allChannels = [ ];
    if (docChannelMap) {
      appendToAuthorizationList(allChannels, docChannelMap.view);
      appendToAuthorizationList(allChannels, docChannelMap.write);
      appendToAuthorizationList(allChannels, docChannelMap.add);
      appendToAuthorizationList(allChannels, docChannelMap.replace);
      appendToAuthorizationList(allChannels, docChannelMap.remove);
    }

    return allChannels;
  }

  // Retrieves a list of authorizations (e.g. channels, roles, users) for the current document write operation type (add, replace or remove)
  function getRequiredAuthorizations(doc, oldDoc, authorizationDefinition) {
    var authorizationMap = getAuthorizationMap(doc, oldDoc, authorizationDefinition);

    if (isValueNullOrUndefined(authorizationMap)) {
      // This document type does not define any authorizations (channels, roles, users) at all
      return null;
    }

    var requiredAuthorizations = [ ];
    var writeAuthorizationFound = false;
    if (authorizationMap.write) {
      writeAuthorizationFound = true;
      appendToAuthorizationList(requiredAuthorizations, authorizationMap.write);
    }

    if (doc._deleted && authorizationMap.remove) {
      writeAuthorizationFound = true;
      appendToAuthorizationList(requiredAuthorizations, authorizationMap.remove);
    } else if (!isDocumentMissingOrDeleted(oldDoc) && authorizationMap.replace) {
      writeAuthorizationFound = true;
      appendToAuthorizationList(requiredAuthorizations, authorizationMap.replace);
    } else if (authorizationMap.add) {
      writeAuthorizationFound = true;
      appendToAuthorizationList(requiredAuthorizations, authorizationMap.add);
    }

    if (writeAuthorizationFound) {
      return requiredAuthorizations;
    } else {
      // This document type does not define any authorizations (channels, roles, users) that apply to this particular write operation type
      return null;
    }
  }

  // Ensures the user is authorized to create/replace/delete this document
  function authorize(doc, oldDoc, docDefinition) {
    var authorizedChannels = getRequiredAuthorizations(doc, oldDoc, docDefinition.channels);
    var authorizedRoles = getRequiredAuthorizations(doc, oldDoc, docDefinition.authorizedRoles);
    var authorizedUsers = getRequiredAuthorizations(doc, oldDoc, docDefinition.authorizedUsers);

    var channelMatch = false;
    if (authorizedChannels) {
      try {
        requireAccess(authorizedChannels);
        channelMatch = true;
      } catch (ex) {
        // The user has none of the authorized channels
        if (!authorizedRoles && !authorizedUsers) {
          // ... and the document definition does not specify any authorized roles or users
          throw ex;
        }
      }
    }

    var roleMatch = false;
    if (authorizedRoles) {
      try {
        requireRole(authorizedRoles);
        roleMatch = true;
      } catch (ex) {
        // The user belongs to none of the authorized roles
        if (!authorizedChannels && !authorizedUsers) {
          // ... and the document definition does not specify any authorized channels or users
          throw ex;
        }
      }
    }

    var userMatch = false;
    if (authorizedUsers) {
      try {
        requireUser(authorizedUsers);
        userMatch = true;
      } catch (ex) {
        // The user does not match any of the authorized usernames
        if (!authorizedChannels && !authorizedRoles) {
          // ... and the document definition does not specify any authorized channels or roles
          throw ex;
        }
      }
    }

    if (!authorizedChannels && !authorizedRoles && !authorizedUsers) {
      // The document type does not define any channels, roles or users that apply to this particular write operation type, so fall back to
      // Sync Gateway's default behaviour for an empty channel list: 403 Forbidden for requests via the public API and either 200 OK or 201
      // Created for requests via the admin API. That way, the admin API will always be able to create, replace or remove documents,
      // regardless of their authorized channels, roles or users, as intended.
      requireAccess([ ]);
    } else if (!channelMatch && !roleMatch && !userMatch) {
      // None of the authorization methods (e.g. channels, roles, users) succeeded
      throw({ forbidden: 'missing channel access' });
    }

    return {
      channels: authorizedChannels,
      roles: authorizedRoles,
      users: authorizedUsers
    };
  }

  var validationModuleDefinition = includeSyncFunctionFragment('sync-function-validation-module.js');
  var validation = validationModuleDefinition();

  // Adds a prefix to the specified item if the prefix is defined
  function prefixItem(item, prefix) {
    return (prefix ? prefix + item : item.toString());
  }

  // Transforms the given item or items into a new list of items with the specified prefix (if any) appended to each element
  function resolveCollectionItems(originalItems, itemPrefix) {
    if (isValueNullOrUndefined(originalItems)) {
      return [ ];
    } else if (originalItems instanceof Array) {
      var resultItems = [ ];
      for (var i = 0; i < originalItems.length; i++) {
        var item = originalItems[i];

        if (isValueNullOrUndefined(item)) {
          continue;
        }

        resultItems.push(prefixItem(item, itemPrefix));
      }

      return resultItems;
    } else {
      // Represents a single item
      return [ prefixItem(originalItems, itemPrefix) ];
    }
  }

  // Transforms the given collection definition, which may have been defined as a single item, a list of items or a function that returns a
  // list of items into a simple list, where each item has the specified prefix, if any
  function resolveCollectionDefinition(doc, oldDoc, collectionDefinition, itemPrefix) {
    if (isValueNullOrUndefined(collectionDefinition)) {
      return [ ];
    } else {
      if (typeof(collectionDefinition) === 'function') {
        var fnResults = collectionDefinition(doc, oldDoc);

        return resolveCollectionItems(fnResults, itemPrefix);
      } else {
        return resolveCollectionItems(collectionDefinition, itemPrefix);
      }
    }
  }

  // Transforms a role collection definition into a simple list and prefixes each element with "role:"
  function resolveRoleCollectionDefinition(doc, oldDoc, rolesDefinition) {
    return resolveCollectionDefinition(doc, oldDoc, rolesDefinition, 'role:');
  }

  // Assigns channel access to users/roles
  function assignChannelsToUsersAndRoles(doc, oldDoc, accessAssignmentDefinition) {
    var usersAndRoles = [ ];

    var users = resolveCollectionDefinition(doc, oldDoc, accessAssignmentDefinition.users);
    for (var userIndex = 0; userIndex < users.length; userIndex++) {
      usersAndRoles.push(users[userIndex]);
    }

    var roles = resolveRoleCollectionDefinition(doc, oldDoc, accessAssignmentDefinition.roles);
    for (var roleIndex = 0; roleIndex < roles.length; roleIndex++) {
      usersAndRoles.push(roles[roleIndex]);
    }

    var channels = resolveCollectionDefinition(doc, oldDoc, accessAssignmentDefinition.channels);

    access(usersAndRoles, channels);

    return {
      type: 'channel',
      usersAndRoles: usersAndRoles,
      channels: channels
    };
  }

  // Assigns role access to users
  function assignRolesToUsers(doc, oldDoc, accessAssignmentDefinition) {
    var users = resolveCollectionDefinition(doc, oldDoc, accessAssignmentDefinition.users);
    var roles = resolveRoleCollectionDefinition(doc, oldDoc, accessAssignmentDefinition.roles);

    role(users, roles);

    return {
      type: 'role',
      users: users,
      roles: roles
    };
  }

  // Assigns role access to users and/or channel access to users/roles according to the given access assignment definitions
  function assignUserAccess(doc, oldDoc, accessAssignmentDefinitions) {
    var effectiveOldDoc = getEffectiveOldDoc(oldDoc);

    var effectiveAssignments = [ ];
    for (var assignmentIndex = 0; assignmentIndex < accessAssignmentDefinitions.length; assignmentIndex++) {
      var definition = accessAssignmentDefinitions[assignmentIndex];

      if (definition.type === 'role') {
        effectiveAssignments.push(assignRolesToUsers(doc, effectiveOldDoc, definition));
      } else if (definition.type === 'channel' || isValueNullOrUndefined(definition.type)) {
        effectiveAssignments.push(assignChannelsToUsersAndRoles(doc, effectiveOldDoc, definition));
      }
    }

    return effectiveAssignments;
  }

  var rawDocDefinitions = %SYNC_DOCUMENT_DEFINITIONS%;

  var docDefinitions;
  if (typeof rawDocDefinitions === 'function') {
    docDefinitions = rawDocDefinitions();
  } else {
    docDefinitions = rawDocDefinitions;
  }

  function getDocumentType(doc, oldDoc) {
    var effectiveOldDoc = getEffectiveOldDoc(oldDoc);

    for (var docType in docDefinitions) {
      var docDefn = docDefinitions[docType];
      if (docDefn.typeFilter(doc, effectiveOldDoc, docType)) {
        return docType;
      }
    }

    // The document type does not exist
    return null;
  }


  // Now put the pieces together
  var theDocType = getDocumentType(doc, oldDoc);

  if (isValueNullOrUndefined(theDocType)) {
    throw({ forbidden: 'Unknown document type' });
  }

  var theDocDefinition = docDefinitions[theDocType];

  // Ensure that, if the document type uses the simple type filter, it supports the "type" property
  if (theDocDefinition.typeFilter === simpleTypeFilter && isValueNullOrUndefined(theDocDefinition.propertyValidators.type)) {
    theDocDefinition.propertyValidators.type = typeIdValidator;
  }

  var customActionMetadata = {
    documentTypeId: theDocType,
    documentDefinition: theDocDefinition
  };

  if (theDocDefinition.customActions && typeof(theDocDefinition.customActions.onTypeIdentificationSucceeded) === 'function') {
    theDocDefinition.customActions.onTypeIdentificationSucceeded(doc, oldDoc, customActionMetadata);
  }

  customActionMetadata.authorization = authorize(doc, oldDoc, theDocDefinition);

  if (theDocDefinition.customActions && typeof(theDocDefinition.customActions.onAuthorizationSucceeded) === 'function') {
    theDocDefinition.customActions.onAuthorizationSucceeded(doc, oldDoc, customActionMetadata);
  }

  validation.validateDoc(doc, oldDoc, theDocDefinition, theDocType);

  if (theDocDefinition.customActions && typeof(theDocDefinition.customActions.onValidationSucceeded) === 'function') {
    theDocDefinition.customActions.onValidationSucceeded(doc, oldDoc, customActionMetadata);
  }

  if (theDocDefinition.accessAssignments && theDocDefinition.accessAssignments.length > 0) {
    customActionMetadata.accessAssignments = assignUserAccess(doc, oldDoc, theDocDefinition.accessAssignments);

    if (theDocDefinition.customActions && typeof(theDocDefinition.customActions.onAccessAssignmentsSucceeded) === 'function') {
      theDocDefinition.customActions.onAccessAssignmentsSucceeded(doc, oldDoc, customActionMetadata);
    }
  }

  // Getting here means the document revision is authorized and valid, and the appropriate channel(s) should now be assigned
  var allDocChannels = getAllDocChannels(doc, oldDoc, theDocDefinition);
  channel(allDocChannels);
  customActionMetadata.documentChannels = allDocChannels;

  if (theDocDefinition.customActions && typeof(theDocDefinition.customActions.onDocumentChannelAssignmentSucceeded) === 'function') {
    theDocDefinition.customActions.onDocumentChannelAssignmentSucceeded(doc, oldDoc, customActionMetadata);
  }
}
